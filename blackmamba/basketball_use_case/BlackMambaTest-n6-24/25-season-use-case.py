# -*- coding: utf-8 -*-
"""BlackMambaTest-n6-24/25-season-use-case.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UE2iAXXFgvScu2nhwZUpnnf3swOVuHI-
"""

!nvidia-smi

# from our blackmamba github  SKIP THIS AND THE NEXT BOX TO USE OPEN SOURCE MAMBA MODEL
import sys
import os
if not os.path.exists('/content/IEOR4212'):
    print("Cloning custom BlackMamba implementation...")
    !git clone https://github.com/Euraba/IEOR4212.git
else:
    print("Repository already exists.")

sys.path.append('/content/IEOR4212')
print("\n--- Available Custom Modules ---")
!ls /content/IEOR4212/blackmamba
try:
    from blackmamba.model import Mamba, ModelArgs
    print("\nâœ… SUCCESS: Loaded custom 'BlackMamba' adaptation.")
except ImportError as e:
    print(f"\nâŒ Import Error: {e}")
    print("Check the file list above. You may need to change 'from blackmamba.model''")

# black mamba # SKIP TO USE OPEN SOURCE MAMBA
from blackmamba.model import Mamba

# OPEN SOURCE MAMBA MODEL
!pip install --upgrade pip
!pip install "mamba-ssm[causal-conv1d]" --no-build-isolation

# OPEN SOURCE MAMBA MODEL
import torch
import sys

# Verify CUDA is available (Mamba requires GPU)
print(f"CUDA available: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"Device: {torch.cuda.get_device_name(0)}")
else:
    print("âš ï¸ WARNING: No GPU detected. Mamba will likely fail.")

# Try importing Mamba to ensure the 'pip install' worked
try:
    from mamba_ssm import Mamba
    print("âœ… Mamba installed and imported successfully!")
except ImportError as e:
    print(f"âŒ Mamba import failed: {e}")
    print("Did you restart the runtime after installing? (Runtime > Restart Session)")

import pandas as pd
import os

# Since you uploaded files to the sidebar on the left,
# they live in the root '/content/' folder.

events_path = "/content/nba_events_2024_2025_with_markets.csv"
prices_path = "/content/nba_event_price_history.csv"

# Check if the computer can find them
if os.path.exists(events_path) and os.path.exists(prices_path):
    print("âœ… Success! Files found.")
    print("You can proceed to Box 3.")
else:
    print("âŒ Files not found.")
    print("Please make sure the filenames match EXACTLY what is in the code above.")
    print(f"Looking for: {events_path}")

import pandas as pd
import ast

# Load just the first 5 rows
df_debug = pd.read_csv(events_path, nrows=5)

print("--- RAW DATA PREVIEW ---")
row = df_debug.iloc[0]
print(f"Outcome Prices (Raw): {row['outcome_prices']}")
print(f"Token IDs (Raw):      {row['token_ids']}")
print(f"Type of outcome_prices: {type(row['outcome_prices'])}")

# Test parsing
try:
    parsed = ast.literal_eval(row['outcome_prices'])
    print(f"âœ… AST Parse Successful: {parsed}")
    print(f"   First price value: {float(parsed[0])}")
except Exception as e:
    print(f"âŒ AST Parse Failed: {e}")

import ast
import pandas as pd
import numpy as np

print("Processing data with Robust Parser...")

# 1. Load Data
df_events = pd.read_csv(events_path)
df_prices = pd.read_csv(prices_path)

# 2. Create a Map of Token_ID -> Winner (1.0) or Loser (0.0)
token_outcome_map = {}
parse_errors = 0

for idx, row in df_events.iterrows():
    try:
        # ast.literal_eval safely handles ['1', '0'] with single quotes
        prices_final = ast.literal_eval(row['outcome_prices'])
        tokens = ast.literal_eval(row['token_ids'])

        # Safety check: Lists must be same length
        if len(prices_final) != len(tokens):
            continue

        # Convert price strings to floats
        float_prices = [float(p) for p in prices_final]
        max_price = max(float_prices)

        # Heuristic: If the highest price is > 0.85, we consider that the winner
        # (Some markets close at 0.99, others 0.95, etc.)
        if max_price > 0.85:
            winner_index = float_prices.index(max_price)

            for i, t_id in enumerate(tokens):
                # The winner gets 1.0, everyone else gets 0.0
                target = 1.0 if i == winner_index else 0.0
                token_outcome_map[str(t_id)] = target

    except Exception as e:
        parse_errors += 1
        continue

print(f"âœ… Mapped outcomes for {len(token_outcome_map)} tokens.")
if parse_errors > 0:
    print(f"âš ï¸ Skipped {parse_errors} rows due to parse errors.")

# 3. Apply Map to Price History
# Ensure token_id is string to match the map keys
df_prices['token_id'] = df_prices['token_id'].astype(str)
df_prices['target'] = df_prices['token_id'].map(token_outcome_map)

# Drop rows where we don't know the result
clean_df = df_prices.dropna(subset=['target']).copy()
clean_df = clean_df.sort_values(['token_id', 'timestamp'])

print(f"Training data ready: {len(clean_df)} rows.")
print("Sample row:")
print(clean_df[['token_id', 'price', 'target']].head(1))

# box 4
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
from mamba_ssm import Mamba

# --- CONFIG ---
SEQ_LEN = 60       # Look back 60 steps (e.g. 1 hour or 5 hours depending on resolution)
BATCH_SIZE = 64
D_MODEL = 64       # Dimension of the vector inside the model

# --- DATASET ---
class PriceDataset(Dataset):
    def __init__(self, df, seq_len):
        self.prices = torch.FloatTensor(df['price'].values).unsqueeze(-1) # (N, 1)
        self.targets = torch.FloatTensor(df['target'].values)
        self.seq_len = seq_len

        # Create valid start indices (must have enough history)
        # We also need to ensure we don't cross between different Tokens (different games)
        # fast trick: strict grouping is better, but for this snippet we'll just check boundaries
        self.indices = []

        # Group by token to ensure we don't construct sequences that jump from Game A to Game B
        grouped = df.groupby('token_id')
        current_idx = 0
        for token, group in grouped:
            group_len = len(group)
            if group_len > seq_len:
                # We can create (group_len - seq_len) sequences here
                # The valid start indices in the global 'prices' tensor:
                starts = list(range(current_idx, current_idx + group_len - seq_len))
                self.indices.extend(starts)
            current_idx += group_len

    def __len__(self):
        return len(self.indices)

    def __getitem__(self, idx):
        # The stored index is the START of the sequence
        start = self.indices[idx]
        end = start + self.seq_len

        x = self.prices[start:end]      # Shape: (60, 1)
        y = self.targets[end-1]         # Shape: scalar (Outcome of the game)
        return x, y

# --- MODEL ---
class MambaPredictor(nn.Module):
    def __init__(self):
        super().__init__()
        self.embedding = nn.Linear(1, D_MODEL) # Expand 1 price -> 64 dim vector

        self.mamba = Mamba(
            d_model=D_MODEL,
            d_state=16,
            d_conv=4,
            expand=2
        )

        self.head = nn.Sequential(
            nn.LayerNorm(D_MODEL),
            nn.Linear(D_MODEL, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        # x: (Batch, Seq, 1)
        x = self.embedding(x)  # (Batch, Seq, 64)
        x = self.mamba(x)      # (Batch, Seq, 64)

        # Take the LAST token in the sequence to predict
        last_hidden = x[:, -1, :]
        return self.head(last_hidden)

# Setup Loaders
# Split 80/20
split = int(len(clean_df) * 0.8)
train_df = clean_df.iloc[:split]
test_df = clean_df.iloc[split:]

train_ds = PriceDataset(train_df, SEQ_LEN)
test_ds = PriceDataset(test_df, SEQ_LEN)

train_loader = DataLoader(train_ds, batch_size=BATCH_SIZE, shuffle=True)
test_loader = DataLoader(test_ds, batch_size=BATCH_SIZE)

print(f"Created {len(train_ds)} training sequences.")

import torch.optim as optim

device = "cuda" if torch.cuda.is_available() else "cpu"
model = MambaPredictor().to(device)
optimizer = optim.Adam(model.parameters(), lr=1e-3)
criterion = nn.BCELoss()

EPOCHS = 3

print(f"Starting training on {device}...")

for epoch in range(EPOCHS):
    model.train()
    total_loss = 0

    for i, (X, y) in enumerate(train_loader):
        X, y = X.to(device), y.to(device).unsqueeze(1)

        optimizer.zero_grad()
        output = model(X)
        loss = criterion(output, y)
        loss.backward()
        optimizer.step()

        total_loss += loss.item()

        if i % 100 == 0:
            print(f"Epoch {epoch+1} | Step {i} | Loss: {loss.item():.4f}")

    # Validation
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for X, y in test_loader:
            X, y = X.to(device), y.to(device).unsqueeze(1)
            output = model(X)
            preds = (output > 0.5).float()
            correct += (preds == y).sum().item()
            total += y.size(0)

    print(f"--- Epoch {epoch+1} Done. Test Accuracy: {correct/total:.2%} ---")

model.eval()
market_correct = 0
model_correct = 0
total_samples = 0

print("Running Reality Check...")

with torch.no_grad():
    for X, y in test_loader:
        X, y = X.to(device), y.to(device).unsqueeze(1)

        # 1. Ask the Model
        model_preds = model(X)

        # 2. Ask the Market (The "Dumb" Strategy)
        # We look at the very last price in the sequence
        # If price > 0.50, the market predicts WIN.
        last_price = X[:, -1, :]
        market_preds = (last_price > 0.5).float()

        # Convert Model probability to 0 or 1
        model_binary = (model_preds > 0.5).float()

        # Compare
        market_correct += (market_preds == y).sum().item()
        model_correct += (model_binary == y).sum().item()
        total_samples += y.size(0)

print(f"\n--- RESULTS ({total_samples} test cases) ---")
print(f"Market Baseline Accuracy: {market_correct/total_samples:.2%}")
print(f"Your Mamba Model Accuracy: {model_correct/total_samples:.2%}")

if model_correct > market_correct:
    print("âœ… SUCCESS: Your model is beating the raw market price!")
else:
    print("âš ï¸ WARNING: Your model is just following the market (or slightly worse).")

initial_bankroll = 10000
bankroll = initial_bankroll
bets_placed = 0
wins = 0

print(f"Starting Simulation with ${bankroll}...")

with torch.no_grad():
    for X, y in test_loader:
        X, y = X.to(device), y.to(device).unsqueeze(1)

        # Get Model Probability (0% to 100%)
        model_probs = model(X)

        # Get Current Market Price
        current_prices = X[:, -1, :]

        # Move to CPU for math
        probs = model_probs.cpu().numpy()
        prices = current_prices.cpu().numpy()
        outcomes = y.cpu().numpy()

        for i in range(len(probs)):
            my_prob = probs[i][0]
            market_price = prices[i][0]
            did_win = outcomes[i][0]

            # THE STRATEGY:
            # Only bet if we think the chance is 5% higher than the cost
            edge = my_prob - market_price

            if edge > 0.05: # 5% confidence threshold
                bet_size = 100
                bets_placed += 1

                # Deduct bet
                bankroll -= bet_size

                # Check result
                if did_win == 1.0:
                    # You win $100 (plus your stake back) approx
                    # In Polymarket, if you buy at 0.60 and win, you get $1.00.
                    # So profit = (1.00 - entry_price) * shares
                    shares = bet_size / market_price
                    payout = shares * 1.00 # It resolves to $1
                    bankroll += payout
                    wins += 1

print(f"\n--- PROFIT REPORT ---")
print(f"Total Bets Placed: {bets_placed}")
if bets_placed > 0:
    print(f"Win Rate on Bets: {wins/bets_placed:.2%}")
print(f"Final Bankroll: ${bankroll:.2f}")
print(f"Net Profit/Loss: ${bankroll - initial_bankroll:.2f}")

import torch

# 1. Check for "Settlement Prices" in the input data
print("Checking for Data Leakage...")
leaks = 0
total_sequences = 0
suspicious_prices = [0.0, 1.0, 0.99, 0.01] # Prices that scream "Game Over"

for X, y in test_loader:
    # X shape: [Batch, Seq_Len, 1]
    # Check the LAST time step of every sequence in the batch
    last_prices = X[:, -1, 0] # Grab the very last price the model sees

    for p in last_prices:
        total_sequences += 1
        # If the model sees a "Settlement Price", it knows the answer!
        if p.item() >= 0.99 or p.item() <= 0.01:
            leaks += 1

print(f"Total Sequences Scanned: {total_sequences}")
print(f"Sequences with 'Leaked' Answers (0.0 or 1.0): {leaks}")
print(f"Leakage Rate: {leaks / total_sequences:.2%}")

if leaks > 0:
    print("ðŸš¨ CRITICAL: Your model is seeing the final result! You must remove the last few rows of every game.")
else:
    print("âœ… CLEAN: No obvious settlement prices in inputs.")

import torch

# Configuration
initial_bankroll = 10000
bankroll = initial_bankroll
bets_placed = 0
wins = 0
skipped_leaks = 0

print(f"Starting REALISTIC Simulation with ${bankroll}...")

with torch.no_grad():
    for X, y in test_loader:
        X, y = X.to(device), y.to(device).unsqueeze(1)

        # 1. Get Model Prediction
        model_probs = model(X)

        # 2. Get Current Market Price (The last price in the sequence)
        current_prices = X[:, -1, :]

        # Move to CPU for calculations
        probs = model_probs.cpu().numpy()
        prices = current_prices.cpu().numpy()
        outcomes = y.cpu().numpy()

        for i in range(len(probs)):
            my_prob = probs[i][0]
            market_price = prices[i][0]
            did_win = outcomes[i][0]

            # --- FILTER 1: REMOVE LEAKS ---
            # If the price is effectively 0 or 1, the game is over.
            # We cannot bet on a game that has already ended.
            if market_price <= 0.02 or market_price >= 0.98:
                skipped_leaks += 1
                continue

            # --- FILTER 2: REALISTIC ENTRY PRICE (SLIPPAGE) ---
            # You can't buy at the mid-price. You buy at the Ask.
            # We add 2 cents spread tax.
            buy_price = market_price + 0.02

            # If buy_price goes over 1.0 (impossible), skip
            if buy_price >= 0.99:
                continue

            # --- STRATEGY ---
            # Edge is now calculated against the EXPENSIVE buy price
            edge = my_prob - buy_price

            # We need a 5% edge AFTER paying the spread
            if edge > 0.05:
                bet_size = 100
                bets_placed += 1

                # Deduct bet
                bankroll -= bet_size

                # Check result
                if did_win == 1.0:
                    # Profit calc:
                    # If you bet $100 at 0.60, you get ~166 shares.
                    # Payout is $166.
                    shares = bet_size / buy_price
                    payout = shares * 1.00
                    bankroll += payout
                    wins += 1

print(f"\n--- REALISTIC PROFIT REPORT ---")
print(f"Skipped {skipped_leaks} 'Leaked' samples (Finished Games)")
print(f"Total Valid Bets Placed: {bets_placed}")

if bets_placed > 0:
    print(f"Win Rate: {wins/bets_placed:.2%}")
    print(f"Final Bankroll: ${bankroll:.2f}")
    profit = bankroll - initial_bankroll
    print(f"Net Profit/Loss: ${profit:.2f}")

    if profit > 0:
        print("âœ… SUCCESS: You have positive alpha even after removing leaks!")
    else:
        print("ðŸ“‰ REALITY CHECK: Without the leaks, the strategy loses money.")
        print("   (This is normal for a V1 model. You need better features/data.)")
else:
    print("âš ï¸ No bets placed. The 'Spread Tax' might be too high for your model's confidence.")

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# 1. RUN SIMULATION & COLLECT STATS
print("Collecting data for visualization...")

bankroll_history = [initial_bankroll]
bets_history = []  # To store (prob, price, outcome, result_dollar)
true_labels = []
pred_labels = []

with torch.no_grad():
    for X, y in test_loader:
        X, y = X.to(device), y.to(device).unsqueeze(1)
        model_probs = model(X).cpu().numpy()
        current_prices = X[:, -1, :].cpu().numpy()
        outcomes = y.cpu().numpy()

        for i in range(len(model_probs)):
            prob = model_probs[i][0]
            price = current_prices[i][0]
            outcome = outcomes[i][0]

            # Record strictly for Confusion Matrix (Raw Accuracy)
            true_labels.append(outcome)
            pred_labels.append(1 if prob > 0.5 else 0)

            # Betting Logic (Same as Box 7)
            if price <= 0.02 or price >= 0.98: continue # Skip Leaks
            buy_price = price + 0.02
            if buy_price >= 0.99: continue

            edge = prob - buy_price
            if edge > 0.05:
                # Place Bet
                bet_size = 100
                shares = bet_size / buy_price

                if outcome == 1.0:
                    profit = (shares * 1.0) - bet_size
                else:
                    profit = -bet_size

                bankroll_history.append(bankroll_history[-1] + profit)
                bets_history.append({
                    'prob': prob,
                    'price': price,
                    'profit': profit,
                    'outcome': outcome
                })

# 2. PLOT THE DASHBOARD
plt.figure(figsize=(18, 5))

# CHART A: The Equity Curve (Profit over Time)
plt.subplot(1, 3, 1)
plt.plot(bankroll_history, color='#00ff41', linewidth=2)
plt.axhline(initial_bankroll, color='white', linestyle='--', alpha=0.5)
plt.title(f"Bankroll Growth (Final: ${bankroll_history[-1]:,.0f})", color='white')
plt.xlabel("Number of Bets", color='white')
plt.ylabel("Account Balance ($)", color='white')
plt.grid(color='#333333')
plt.gca().set_facecolor('#111111')
plt.tick_params(colors='white')

# CHART B: Model Confidence vs Market Price
# (Are we betting on Longshots or Favorites?)
if len(bets_history) > 0:
    df_bets = pd.DataFrame(bets_history)

    plt.subplot(1, 3, 2)
    # Scatter plot: x=Market Price, y=Model Prob
    # Green dots = Wins, Red dots = Losses
    colors = df_bets['profit'].apply(lambda x: '#00ff41' if x > 0 else '#ff0055')

    plt.scatter(df_bets['price'], df_bets['prob'], c=colors, alpha=0.6, s=15)
    plt.plot([0, 1], [0, 1], color='white', linestyle='--', label="Market Line") # Diagonal

    plt.title("Bet Distribution (Green=Win, Red=Loss)", color='white')
    plt.xlabel("Market Price", color='white')
    plt.ylabel("Model Probability", color='white')
    plt.grid(color='#333333')
    plt.gca().set_facecolor('#111111')
    plt.tick_params(colors='white')

plt.subplot(1, 3, 3)
cm = confusion_matrix(true_labels, pred_labels)
sns.heatmap(cm, annot=True, fmt='d', cmap='Greens', cbar=False,
            xticklabels=['Pred Lose', 'Pred Win'],
            yticklabels=['Actual Lose', 'Actual Win'])
plt.title("Prediction Accuracy Matrix", color='black')

plt.tight_layout()
plt.gcf().patch.set_facecolor('#0d0d0d')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

# Check if we have history from the previous step
if 'bets_history' in locals() and len(bets_history) > 0:
    df = pd.DataFrame(bets_history)

    # Categorize bets into "Price Zones"
    bins = [0.0, 0.50, 0.60, 0.70, 0.80, 0.90, 1.0]
    labels = ['<0.50', '0.50-0.60', '0.60-0.70', '0.70-0.80', '0.80-0.90', '>0.90']
    df['zone'] = pd.cut(df['price'], bins=bins, labels=labels)

    # Calculate stats per zone
    zone_stats = df.groupby('zone').agg(
        bets=('profit', 'count'),
        wins=('profit', lambda x: (x > 0).sum()),
        total_profit=('profit', 'sum'),
        roi=('profit', lambda x: x.sum() / (x.count() * 100)) # Approx ROI assuming $100 bets
    )

    # Calculate Win Rate
    zone_stats['win_rate'] = zone_stats['wins'] / zone_stats['bets']

    print("--- PROFIT BY PRICE ZONE ---")
    print(zone_stats[['bets', 'win_rate', 'total_profit']].sort_index(ascending=False))

    # Visualization
    colors = ['red' if x < 0 else 'green' for x in zone_stats['total_profit']]
    zone_stats['total_profit'].plot(kind='bar', color=colors, figsize=(10, 5))
    plt.title("Where do you make money?")
    plt.ylabel("Net Profit ($)")
    plt.axhline(0, color='white', alpha=0.3)
    plt.grid(axis='y', alpha=0.3)
    plt.gcf().set_facecolor('#111111')
    plt.gca().set_facecolor('#111111')
    plt.tick_params(colors='white')
    plt.show()

else:
    print("âŒ No bet history found. Please re-run Box 8 first.")
